<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEGO Builder</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background: #0f172a;
            color: #e2e8f0;
        }

        /* Floating Header */
        #header {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            display: flex;
            align-items: center;
            gap: 24px;
            z-index: 100;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        #header h1 {
            color: #fff;
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, #f43f5e 0%, #e11d48 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-info {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: #94a3b8;
        }

        .header-info strong {
            color: #f8fafc;
            font-weight: 600;
        }

        /* Fullscreen Canvas */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
            z-index: 0;
        }

        /* Floating Control Panel */
        #control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            bottom: 20px;
            width: 320px;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            overflow-y: auto;
            padding: 20px;
            z-index: 100;
            box-shadow: -4px 0 30px rgba(0, 0, 0, 0.3);
            scrollbar-width: thin;
            scrollbar-color: #334155 transparent;
        }

        #control-panel::-webkit-scrollbar {
            width: 6px;
        }

        #control-panel::-webkit-scrollbar-thumb {
            background-color: #334155;
            border-radius: 3px;
        }

        .panel-section {
            margin-bottom: 24px;
        }

        .panel-section h3 {
            color: #94a3b8;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-section h3::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255,255,255,0.1);
        }

        /* Tool Buttons */
        .tool-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            background: rgba(0, 0, 0, 0.2);
            padding: 4px;
            border-radius: 12px;
        }

        .tool-btn {
            padding: 10px 4px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: #94a3b8;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: inherit;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
        }

        .tool-btn.active {
            background: #3b82f6;
            color: #fff;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        /* Action Buttons */
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .action-btn {
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            background: rgba(30, 41, 59, 0.5);
            color: #cbd5e1;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            font-family: inherit;
        }

        .action-btn:hover {
            background: #334155;
            color: #fff;
            border-color: rgba(255,255,255,0.1);
            transform: translateY(-1px);
        }

        .action-btn:active {
            transform: translateY(0);
        }

        .action-btn.danger {
            background: rgba(220, 38, 38, 0.1);
            color: #f87171;
            border-color: rgba(220, 38, 38, 0.2);
        }

        .action-btn.danger:hover {
            background: rgba(220, 38, 38, 0.2);
            color: #fca5a5;
        }

        /* Brick Grid */
        .brick-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .brick-btn {
            padding: 12px 4px;
            border: 1px solid transparent;
            border-radius: 10px;
            background: #1e293b;
            color: #cbd5e1;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
            font-family: inherit;
        }

        .brick-btn:hover {
            background: #334155;
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .brick-btn.selected {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: #fff;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
            transform: translateY(-1px);
        }

        /* Color Palette */
        .color-palette {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid rgba(255,255,255,0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .color-swatch:hover {
            transform: scale(1.15);
            border-color: rgba(255,255,255,0.5);
            z-index: 10;
        }

        .color-swatch.selected {
            border-color: #fff;
            box-shadow: 0 0 0 2px rgba(15, 23, 42, 0.8), 0 0 0 4px #fff;
            transform: scale(1.1);
            z-index: 2;
        }

        /* Info & Rotation */
        #info-display {
            background: rgba(0,0,0,0.2);
            padding: 12px;
            border-radius: 12px;
            font-size: 12px;
            color: #94a3b8;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #info-display span {
            color: #38bdf8;
            float: right;
        }

        .rotation-display {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            font-size: 11px;
            color: #94a3b8;
            font-family: monospace;
        }

        .rotation-display span {
            color: #f43f5e;
            font-weight: bold;
        }

        /* Toast */
        #toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(15, 23, 42, 0.9);
            color: #fff;
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 1000;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(12px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        #toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Modals */
        #save-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            backdrop-filter: blur(4px);
        }

        #save-modal.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: #1e293b;
            padding: 32px;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .modal-content h2 {
            color: #fff;
            font-weight: 700;
            font-size: 24px;
            background: linear-gradient(135deg, #fff 0%, #94a3b8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
        }

        .save-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 8px;
            background: rgba(0,0,0,0.2);
        }

        .save-item {
            background: #334155;
            border-radius: 12px;
            margin-bottom: 8px;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        .save-item:hover {
            background: #475569;
            border-color: #64748b;
        }

        .save-item-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .save-name {
            color: #fff;
            font-weight: 600;
            font-size: 14px;
        }

        .save-date {
            color: #94a3b8;
            font-size: 11px;
        }

        .save-actions {
            display: flex;
            gap: 8px;
        }

        .save-btn-action {
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .load-btn {
            background: #3b82f6;
            color: #fff;
        }

        .load-btn:hover {
            background: #2563eb;
        }

        .delete-btn {
            background: rgba(220, 38, 38, 0.2);
            color: #fca5a5;
        }

        .delete-btn:hover {
            background: rgba(220, 38, 38, 0.4);
            color: #fff;
        }

        .close-modal {
            background: #334155;
            color: #fff;
            padding: 12px;
            border-radius: 12px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .close-modal:hover {
            background: #475569;
        }

</style>
</head>
<body>
    <div id="header">
        <h1>üß± LEGO Builder</h1>
        <div class="header-info">
            <span>Bricks: <strong id="brick-count-header">0</strong></span>
            <span>Tool: <strong id="current-tool-header">Place</strong></span>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="control-panel">
        <div class="panel-section">
            <h3>üîß Tools</h3>
            <div class="tool-buttons">
                <button class="tool-btn active" data-tool="place" title="Place bricks">Place</button>
                <button class="tool-btn" data-tool="select" title="Select bricks">Select</button>
                <button class="tool-btn" data-tool="paint" title="Paint bricks">Paint</button>
                <button class="tool-btn" data-tool="delete" title="Delete bricks">Delete</button>
            </div>
        </div>

        <div class="panel-section">
            <h3>üß± Brick Type</h3>
            <div class="brick-grid" id="brick-inventory"></div>
        </div>

        <div class="panel-section">
            <h3>üé® Colors</h3>
            <div class="color-palette" id="color-palette"></div>
        </div>

        <div class="panel-section">
            <h3>üîÑ Rotation</h3>
            <div class="tool-buttons">
                <button class="action-btn" id="rotate-x" title="Rotate around X axis">X +90¬∞</button>
                <button class="action-btn" id="rotate-y" title="Rotate around Y axis">Y +90¬∞</button>
                <button class="action-btn" id="rotate-z" title="Rotate around Z axis">Z +90¬∞</button>
                <button class="action-btn" id="reset-rotation" title="Reset rotation">Reset</button>
            </div>
            <div class="rotation-display">
                <div>X: <span id="rot-x">0¬∞</span></div>
                <div>Y: <span id="rot-y">0¬∞</span></div>
                <div>Z: <span id="rot-z">0¬∞</span></div>
            </div>
        </div>

        <div class="panel-section">
            <h3>‚ö° Actions</h3>
            <div class="action-buttons">
                <button class="action-btn" id="undo-btn" title="Undo (Ctrl+Z)">‚Ü© Undo</button>
                <button class="action-btn" id="redo-btn" title="Redo (Ctrl+Y)">‚Ü™ Redo</button>
                <button class="action-btn" id="save-btn" title="Save/Load project">üíæ Save</button>
                <button class="action-btn" id="clone-btn" title="Duplicate selected">üìã Clone</button>
                <button class="action-btn" id="export-btn" title="Export screenshot">üì∏ Export</button>
                <button class="action-btn" id="grid-btn" title="Toggle grid">üìè Grid</button>
                <button class="action-btn" id="theme-btn" title="Toggle theme">üåó Theme</button>
                <button class="action-btn" id="select-all-btn" title="Select all bricks">‚úÖ Select All</button>
                <button class="action-btn danger" id="clear-btn" title="Clear all bricks">üóë Clear</button>
            </div>
        </div>

        <div class="panel-section">
            <h3>üòà Cheats</h3>
            <div class="action-buttons">
                <button class="action-btn" id="cheat-noclip" title="Toggle collision (No Clip)">üëª No Clip</button>
                <button class="action-btn" id="cheat-random" title="Randomize colors">üåà Colors</button>
            </div>
        </div>

        <div class="panel-section">
            <h3>üìä Info</h3>
            <div id="info-display">
                <div>Total Bricks: <span id="brick-count">0</span></div>
                <div>Selected: <span id="selected-count">0</span></div>
                <div>Current Brick: <span id="current-brick">1√ó1</span></div>
            </div>
        </div>
    </div>

    <div id="toast"></div>


    <div id="save-modal">
        <div class="modal-content">
            <h2>üìÇ Saved Builds</h2>
            <button class="action-btn" style="margin-bottom: 10px; width: 100%;" onclick="saveProjectCurrent()">+ Save Current Build</button>
            <div class="save-list" id="save-list"></div>
            <button class="close-modal" onclick="closeModal('save-modal')">Close</button>
        </div>
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            gridSize: 20,
            studSize: 0.5,
            plateHeight: 0.33,
            brickHeight: 1.0,
            maxHistory: 50,
            colors: [
                { name: 'Red', hex: '#e63946' },
                { name: 'Blue', hex: '#2660a4' },
                { name: 'Green', hex: '#2a9d8f' },
                { name: 'Yellow', hex: '#ffd60a' },
                { name: 'White', hex: '#f8f9fa' },
                { name: 'Black', hex: '#1a1a1a' },
                { name: 'Orange', hex: '#fb8500' },
                { name: 'Purple', hex: '#7b2cbf' },
                { name: 'Pink', hex: '#ff69b4' },
                { name: 'Cyan', hex: '#00b4d8' },
                { name: 'Brown', hex: '#8b5a2b' },
                { name: 'Gray', hex: '#6c757d' }
            ],
            brickTypes: [
                { id: '1x1', name: '1√ó1', width: 1, depth: 1, type: 'brick' },
                { id: '1x2', name: '1√ó2', width: 1, depth: 2, type: 'brick' },
                { id: '1x4', name: '1√ó4', width: 1, depth: 4, type: 'brick' },
                { id: '2x2', name: '2√ó2', width: 2, depth: 2, type: 'brick' },
                { id: '2x4', name: '2√ó4', width: 2, depth: 4, type: 'brick' },
                { id: '2x6', name: '2√ó6', width: 2, depth: 6, type: 'brick' },
                { id: '1x1p', name: '1√ó1 Plt', width: 1, depth: 1, type: 'plate' },
                { id: '2x2p', name: '2√ó2 Plt', width: 2, depth: 2, type: 'plate' },
                { id: '2x4p', name: '2√ó4 Plt', width: 2, depth: 4, type: 'plate' }
            ]
        };

        // ==================== SYSTEMS ====================

        // Spatial Grid for optimized collision/gravity
        class SpatialGrid {
            constructor(cellSize = CONFIG.studSize) {
                this.cellSize = cellSize;
                this.cells = new Map(); // "x,z" -> Set<brickId>
            }

            getKey(x, z) {
                const cx = Math.floor(x / this.cellSize);
                const cz = Math.floor(z / this.cellSize);
                return `${cx},${cz}`;
            }

            // Get all cells a brick occupies
            getBrickCells(brick) {
                const keys = new Set();
                const bounds = getWorldBounds(brick.position, brick.type, brick.rotation);
                // Expand bounds slightly to catch edges
                const minX = Math.floor(bounds.min.x / this.cellSize);
                const maxX = Math.floor(bounds.max.x / this.cellSize);
                const minZ = Math.floor(bounds.min.z / this.cellSize);
                const maxZ = Math.floor(bounds.max.z / this.cellSize);

                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        keys.add(`${x},${z}`);
                    }
                }
                return keys;
            }

            add(brick) {
                const keys = this.getBrickCells(brick);
                keys.forEach(key => {
                    if (!this.cells.has(key)) this.cells.set(key, new Set());
                    this.cells.get(key).add(brick.id);
                });
            }

            remove(brick) {
                const keys = this.getBrickCells(brick);
                keys.forEach(key => {
                    if (this.cells.has(key)) {
                        const cell = this.cells.get(key);
                        cell.delete(brick.id);
                        if (cell.size === 0) this.cells.delete(key);
                    }
                });
            }

            getNearbyBricks(brick, excludeId = null) {
                const candidates = new Set();
                const keys = this.getBrickCells(brick);
                keys.forEach(key => {
                    if (this.cells.has(key)) {
                        this.cells.get(key).forEach(id => {
                            if (id !== brick.id && id !== excludeId) {
                                candidates.add(id);
                            }
                        });
                    }
                });
                return Array.from(candidates);
            }

            clear() {
                this.cells.clear();
            }
        }

        // Render Manager for InstancedMesh
        class RenderManager {
            constructor() {
                this.instancedMeshes = new Map(); // typeId -> InstancedMesh
                this.brickToInstance = new Map(); // brickId -> { typeId, instanceId }
                this.geometries = new Map(); // typeId -> BufferGeometry
                this.selectionMeshes = new Map(); // brickId -> Mesh (LineSegments)
            }

            init(scene) {
                this.scene = scene;
                // Pre-generate geometries
                CONFIG.brickTypes.forEach(type => {
                    const geo = createBrickGeometry(type);
                    this.geometries.set(type.id, geo);

                    // Create InstancedMesh
                    const material = new THREE.MeshStandardMaterial({
                        roughness: 0.3,
                        metalness: 0.1
                    });
                    const maxCount = 10000;
                    const mesh = new THREE.InstancedMesh(geo, material, maxCount);
                    mesh.count = 0;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData.typeId = type.id;

                    // Initialize matrix array to avoid bounding box issues
                    // for (let i = 0; i < maxCount; i++) mesh.setMatrixAt(i, new THREE.Matrix4());

                    scene.add(mesh);
                    this.instancedMeshes.set(type.id, mesh);
                });
            }

            addBrick(brick) {
                const mesh = this.instancedMeshes.get(brick.type.id);
                if (!mesh) return;

                if (mesh.count >= mesh.instanceMatrix.count) {
                    console.warn('Max brick count reached for type ' + brick.type.id);
                    // TODO: Resize logic could go here
                    return;
                }

                const index = mesh.count;

                // Update matrix
                const matrix = new THREE.Matrix4();
                const rotation = new THREE.Euler(
                    THREE.MathUtils.degToRad(brick.rotation.x),
                    THREE.MathUtils.degToRad(brick.rotation.y),
                    THREE.MathUtils.degToRad(brick.rotation.z),
                    'XYZ'
                );
                const quaternion = new THREE.Quaternion().setFromEuler(rotation);
                matrix.compose(
                    new THREE.Vector3(brick.position.x, brick.position.y, brick.position.z),
                    quaternion,
                    new THREE.Vector3(1, 1, 1)
                );

                mesh.setMatrixAt(index, matrix);
                mesh.setColorAt(index, new THREE.Color(brick.color));

                mesh.count++;
                mesh.instanceMatrix.needsUpdate = true;
                if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;

                // Map brickId to this instance
                this.brickToInstance.set(brick.id, {
                    typeId: brick.type.id,
                    instanceId: index
                });

                // Store brickId in mesh userData for raycasting reverse lookup
                if (!mesh.userData.brickIds) mesh.userData.brickIds = [];
                mesh.userData.brickIds[index] = brick.id;
            }

            removeBrick(brickId) {
                const info = this.brickToInstance.get(brickId);
                if (!info) return;

                const mesh = this.instancedMeshes.get(info.typeId);
                const index = info.instanceId;
                const lastIndex = mesh.count - 1;

                if (index !== lastIndex) {
                    // Swap with last
                    const lastMatrix = new THREE.Matrix4();
                    const lastColor = new THREE.Color();

                    mesh.getMatrixAt(lastIndex, lastMatrix);
                    mesh.getColorAt(lastIndex, lastColor);

                    mesh.setMatrixAt(index, lastMatrix);
                    mesh.setColorAt(index, lastColor);

                    // Update map for the moved brick
                    const lastBrickId = mesh.userData.brickIds[lastIndex];
                    this.brickToInstance.set(lastBrickId, {
                        typeId: info.typeId,
                        instanceId: index
                    });
                    mesh.userData.brickIds[index] = lastBrickId;
                }

                mesh.count--;
                mesh.instanceMatrix.needsUpdate = true;
                if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;

                this.brickToInstance.delete(brickId);
                this.removeHighlight(brickId);
            }

            updateBrickColor(brick) {
                const info = this.brickToInstance.get(brick.id);
                if (!info) return;

                const mesh = this.instancedMeshes.get(info.typeId);
                mesh.setColorAt(info.instanceId, new THREE.Color(brick.color));
                if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
            }

            updateBrickTransformation(brick) {
                // Remove and re-add is easiest to handle sorting/swapping logic,
                // but updating matrix in place is faster if we didn't use swap-remove.
                // Since we use swap-remove, ID persistence at index is fragile if we don't track it carefully.
                // Re-using setMatrixAt is fine.
                const info = this.brickToInstance.get(brick.id);
                if (!info) return;

                const mesh = this.instancedMeshes.get(info.typeId);
                const matrix = new THREE.Matrix4();
                 const rotation = new THREE.Euler(
                    THREE.MathUtils.degToRad(brick.rotation.x),
                    THREE.MathUtils.degToRad(brick.rotation.y),
                    THREE.MathUtils.degToRad(brick.rotation.z),
                    'XYZ'
                );
                const quaternion = new THREE.Quaternion().setFromEuler(rotation);
                matrix.compose(
                    new THREE.Vector3(brick.position.x, brick.position.y, brick.position.z),
                    quaternion,
                    new THREE.Vector3(1, 1, 1)
                );
                mesh.setMatrixAt(info.instanceId, matrix);
                mesh.instanceMatrix.needsUpdate = true;
            }

            addHighlight(brick) {
                if (this.selectionMeshes.has(brick.id)) return;

                const geometry = new THREE.EdgesGeometry(createBrickGeometry(brick.type));
                const material = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
                const mesh = new THREE.LineSegments(geometry, material);

                mesh.position.set(brick.position.x, brick.position.y, brick.position.z);
                mesh.rotation.set(
                    THREE.MathUtils.degToRad(brick.rotation.x),
                    THREE.MathUtils.degToRad(brick.rotation.y),
                    THREE.MathUtils.degToRad(brick.rotation.z)
                );

                this.scene.add(mesh);
                this.selectionMeshes.set(brick.id, mesh);
            }

            removeHighlight(brickId) {
                const mesh = this.selectionMeshes.get(brickId);
                if (mesh) {
                    this.scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                    this.selectionMeshes.delete(brickId);
                }
            }

            clear() {
                this.instancedMeshes.forEach(mesh => {
                    mesh.count = 0;
                    mesh.instanceMatrix.needsUpdate = true;
                    mesh.userData.brickIds = [];
                });
                this.brickToInstance.clear();

                this.selectionMeshes.forEach(mesh => {
                    this.scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                });
                this.selectionMeshes.clear();
            }

            getRaycastIntersects(raycaster) {
                // Gather all instanced meshes
                const meshes = Array.from(this.instancedMeshes.values());
                const intersects = raycaster.intersectObjects(meshes, false);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const mesh = hit.object;
                    const instanceId = hit.instanceId;

                    if (mesh.userData.brickIds && mesh.userData.brickIds[instanceId]) {
                         return {
                             brickId: mesh.userData.brickIds[instanceId],
                             object: mesh,
                             point: hit.point,
                             face: hit.face
                         };
                    }
                }
                return null;
            }
        }

        // ==================== GAME STATE ====================
        let gameState = {
            bricks: [],
            selectedBrickIds: [],
            history: [],
            historyIndex: -1,
            currentTool: 'place',
            currentBrickType: CONFIG.brickTypes[0],
            currentColor: CONFIG.colors[0].hex,
            currentRotation: { x: 0, y: 0, z: 0 },
            cheats: {
                noClip: false
            }
        };

        const renderManager = new RenderManager();
        const spatialGrid = new SpatialGrid();

        // ==================== THREE.JS VARIABLES ====================
        let scene, camera, renderer;
        let ghostBrick = null;
        let groundPlane;

        // Camera control state
        let cameraState = {
            isRotating: false,
            isPanning: false,
            lastMouseX: 0,
            lastMouseY: 0,
            theta: Math.PI / 4,
            phi: Math.PI / 3,
            radius: 20,
            target: new THREE.Vector3(0, 0, 0)
        };

        // ==================== INITIALIZATION ====================
        function init() {
            initThree();
            setupUI();
            setupKeyboardShortcuts();
            saveToHistory();
            updateInfo();
            showToast('Welcome to LEGO Builder!');
        }

        function initThree() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2634);
            scene.fog = new THREE.Fog(0x1a2634, 30, 80);

            // Camera
            camera = new THREE.PerspectiveCamera(
                55,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lighting
            setupLighting();

            // Ground and Grid
            createGroundAndGrid();

            // Initialize Render Manager
            renderManager.init(scene);

            // Ghost brick preview
            createGhostBrick();

            // Camera controls
            setupCameraControls(container);

            // Initial camera position
            updateCameraPosition();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            container.addEventListener('click', handleCanvasClick);
            container.addEventListener('mousemove', handleMouseMove);

            // Start render loop
            animate();
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Main directional light
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(15, 25, 15);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 1;
            mainLight.shadow.camera.far = 60;
            mainLight.shadow.camera.left = -20;
            mainLight.shadow.camera.right = 20;
            mainLight.shadow.camera.top = 20;
            mainLight.shadow.camera.bottom = -20;
            mainLight.shadow.bias = -0.001;
            scene.add(mainLight);

            // Fill light
            const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);

            // Hemisphere light for ambient
            const hemiLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.3);
            scene.add(hemiLight);
        }

        function createGroundAndGrid() {
            // Ground plane
            const groundGeo = new THREE.PlaneGeometry(CONFIG.gridSize * 2, CONFIG.gridSize * 2);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x3d5a4c,
                roughness: 0.9,
                metalness: 0.1
            });
            groundPlane = new THREE.Mesh(groundGeo, groundMat);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = -0.01;
            groundPlane.receiveShadow = true;
            groundPlane.name = 'ground';
            scene.add(groundPlane);

            // Grid helper
            const gridHelper = new THREE.GridHelper(CONFIG.gridSize, CONFIG.gridSize * 2, 0x557755, 0x446644);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Axis indicator
            const axesHelper = new THREE.AxesHelper(3);
            axesHelper.position.set(-CONFIG.gridSize/2 + 1, 0.1, -CONFIG.gridSize/2 + 1);
            scene.add(axesHelper);
        }

        function createBrickGeometry(brickType) {
             // Geometry reuse is handled by RenderManager init, but we keep this for ghost brick and helpers
            const width = brickType.width * CONFIG.studSize;
            const depth = brickType.depth * CONFIG.studSize;
            const height = brickType.type === 'plate' ? CONFIG.plateHeight : CONFIG.brickHeight;

            const group = new THREE.Group();

            // Main body
            const bodyGeo = new THREE.BoxGeometry(width - 0.02, height - 0.02, depth - 0.02);
            const bodyMesh = new THREE.Mesh(bodyGeo);
            bodyMesh.position.y = height / 2;
            group.add(bodyMesh);

            // Add studs
            const studRadius = CONFIG.studSize * 0.3;
            const studHeight = 0.12;
            const studGeo = new THREE.CylinderGeometry(studRadius, studRadius * 1.05, studHeight, 12);

            for (let x = 0; x < brickType.width; x++) {
                for (let z = 0; z < brickType.depth; z++) {
                    const stud = new THREE.Mesh(studGeo);
                    stud.position.x = (x - (brickType.width - 1) / 2) * CONFIG.studSize;
                    stud.position.y = height + studHeight / 2 - 0.01;
                    stud.position.z = (z - (brickType.depth - 1) / 2) * CONFIG.studSize;
                    group.add(stud);
                }
            }

            return mergeGroupGeometry(group);
        }

        function mergeGroupGeometry(group) {
            const positions = [];
            const normals = [];
            const indices = [];
            let indexOffset = 0;

            group.updateMatrixWorld(true);

            group.children.forEach(child => {
                const geo = child.geometry.clone();
                geo.applyMatrix4(child.matrixWorld);

                const pos = geo.getAttribute('position');
                const norm = geo.getAttribute('normal');
                const idx = geo.getIndex();

                for (let i = 0; i < pos.count; i++) {
                    positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                    normals.push(norm.getX(i), norm.getY(i), norm.getZ(i));
                }

                if (idx) {
                    for (let i = 0; i < idx.count; i++) {
                        indices.push(idx.getX(i) + indexOffset);
                    }
                }

                indexOffset += pos.count;
            });

            const mergedGeo = new THREE.BufferGeometry();
            mergedGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            mergedGeo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            if (indices.length > 0) {
                mergedGeo.setIndex(indices);
            }
            mergedGeo.computeBoundingBox();

            return mergedGeo;
        }

        function createGhostBrick() {
            updateGhostBrick();
        }

        function updateGhostBrick() {
            if (ghostBrick) {
                scene.remove(ghostBrick);
                if (ghostBrick.geometry) ghostBrick.geometry.dispose();
                if (ghostBrick.material) ghostBrick.material.dispose();
            }

            const geometry = createBrickGeometry(gameState.currentBrickType);
            const material = new THREE.MeshStandardMaterial({
                color: gameState.currentColor,
                transparent: true,
                opacity: 0.6,
                roughness: 0.5
            });

            ghostBrick = new THREE.Mesh(geometry, material);
            ghostBrick.visible = false;
            ghostBrick.name = 'ghost';
            scene.add(ghostBrick);

            updateRotationDisplay();
        }

        // ==================== CAMERA CONTROLS ====================
        function setupCameraControls(container) {
            container.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    cameraState.isRotating = true;
                    cameraState.lastMouseX = e.clientX;
                    cameraState.lastMouseY = e.clientY;
                    e.preventDefault();
                } else if (e.button === 1) {
                    cameraState.isPanning = true;
                    cameraState.lastMouseX = e.clientX;
                    cameraState.lastMouseY = e.clientY;
                    e.preventDefault();
                }
            });

            container.addEventListener('mouseup', () => {
                cameraState.isRotating = false;
                cameraState.isPanning = false;
            });

            container.addEventListener('mouseleave', () => {
                cameraState.isRotating = false;
                cameraState.isPanning = false;
            });

            container.addEventListener('mousemove', (e) => {
                const deltaX = e.clientX - cameraState.lastMouseX;
                const deltaY = e.clientY - cameraState.lastMouseY;

                if (cameraState.isRotating) {
                    cameraState.theta -= deltaX * 0.008;
                    cameraState.phi = Math.max(0.2, Math.min(Math.PI / 2 - 0.1, cameraState.phi - deltaY * 0.008));
                    updateCameraPosition();
                }

                if (cameraState.isPanning) {
                    const panSpeed = 0.02;
                    cameraState.target.x -= deltaX * panSpeed;
                    cameraState.target.z -= deltaY * panSpeed;
                    updateCameraPosition();
                }

                cameraState.lastMouseX = e.clientX;
                cameraState.lastMouseY = e.clientY;
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraState.radius = Math.max(5, Math.min(50, cameraState.radius + e.deltaY * 0.03));
                updateCameraPosition();
            }, { passive: false });

            container.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function updateCameraPosition() {
            camera.position.x = cameraState.target.x + cameraState.radius * Math.sin(cameraState.phi) * Math.cos(cameraState.theta);
            camera.position.y = cameraState.target.y + cameraState.radius * Math.cos(cameraState.phi);
            camera.position.z = cameraState.target.z + cameraState.radius * Math.sin(cameraState.phi) * Math.sin(cameraState.theta);
            camera.lookAt(cameraState.target);
        }

        // ==================== RAYCASTING ====================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function getIntersection(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check bricks via RenderManager
            const brickHit = renderManager.getRaycastIntersects(raycaster);
            if (brickHit) {
                return { type: 'brick', intersection: brickHit, brickId: brickHit.brickId };
            }

            // Check ground
            const groundIntersects = raycaster.intersectObject(groundPlane);
            if (groundIntersects.length > 0) {
                return { type: 'ground', intersection: groundIntersects[0] };
            }

            return null;
        }

        function handleMouseMove(event) {
            if (gameState.currentTool === 'place') {
                updateGhostPosition(event);
            } else if (ghostBrick) {
                ghostBrick.visible = false;
            }
        }

        function updateGhostPosition(event) {
            if (!ghostBrick) return;

            const result = getIntersection(event);

            if (result) {
                ghostBrick.visible = true;

                const point = result.intersection.point;
                const snapped = snapPosition(point, gameState.currentBrickType, gameState.currentRotation);

                let y = 0;
                if (result.type === 'brick') {
                    const hitBrick = gameState.bricks.find(b => b.id === result.brickId);
                    if (hitBrick) {
                        const bBounds = getWorldBounds(hitBrick.position, hitBrick.type, hitBrick.rotation);
                        y = bBounds.max.y;
                    }
                }

                const local = getLocalBounds(gameState.currentBrickType, gameState.currentRotation);
                const placementY = y - local.min.y;

                ghostBrick.position.set(snapped.x, placementY, snapped.z);
                ghostBrick.rotation.set(
                    THREE.MathUtils.degToRad(gameState.currentRotation.x),
                    THREE.MathUtils.degToRad(gameState.currentRotation.y),
                    THREE.MathUtils.degToRad(gameState.currentRotation.z)
                );

                // Check collision and update color
                const hasCollision = checkCollision(snapped.x, placementY, snapped.z, gameState.currentBrickType, gameState.currentRotation);

                if (hasCollision) {
                    ghostBrick.material.color.setHex(0xff3333);
                    ghostBrick.material.opacity = 0.4;
                } else {
                    ghostBrick.material.color.set(gameState.currentColor);
                    ghostBrick.material.opacity = 0.6;
                }
            } else {
                ghostBrick.visible = false;
            }
        }

        function snapPosition(point, brickType, rotation) {
            const unit = CONFIG.studSize;

            // Determine effective dimensions after rotation
            let effWidth = brickType.width;
            let effDepth = brickType.depth;

            const yRot = ((rotation.y % 360) + 360) % 360;
            if (yRot === 90 || yRot === 270) {
                effWidth = brickType.depth;
                effDepth = brickType.width;
            }

            // Calculate offset for centering
            const offsetX = (effWidth % 2 === 0) ? 0 : unit / 2;
            const offsetZ = (effDepth % 2 === 0) ? 0 : unit / 2;

            return {
                x: Math.round((point.x - offsetX) / unit) * unit + offsetX,
                z: Math.round((point.z - offsetZ) / unit) * unit + offsetZ
            };
        }

        function getLocalBounds(brickType, rotation) {
            const w = brickType.width * CONFIG.studSize;
            const h = brickType.type === 'plate' ? CONFIG.plateHeight : CONFIG.brickHeight;
            const d = brickType.depth * CONFIG.studSize;

            // Define corners relative to pivot (which is bottom-center of the unrotated brick)
            const min = new THREE.Vector3(-w/2, 0, -d/2);
            const max = new THREE.Vector3(w/2, h, d/2);

            const corners = [
                new THREE.Vector3(min.x, min.y, min.z),
                new THREE.Vector3(max.x, min.y, min.z),
                new THREE.Vector3(min.x, max.y, min.z),
                new THREE.Vector3(max.x, max.y, min.z),
                new THREE.Vector3(min.x, min.y, max.z),
                new THREE.Vector3(max.x, min.y, max.z),
                new THREE.Vector3(min.x, max.y, max.z),
                new THREE.Vector3(max.x, max.y, max.z)
            ];

            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(rotation.x),
                THREE.MathUtils.degToRad(rotation.y),
                THREE.MathUtils.degToRad(rotation.z),
                'XYZ'
            );

            const rotatedMin = new THREE.Vector3(Infinity, Infinity, Infinity);
            const rotatedMax = new THREE.Vector3(-Infinity, -Infinity, -Infinity);

            corners.forEach(p => {
                p.applyEuler(euler);
                rotatedMin.min(p);
                rotatedMax.max(p);
            });

            return { min: rotatedMin, max: rotatedMax };
        }

        function getWorldBounds(position, brickType, rotation) {
            const local = getLocalBounds(brickType, rotation);
            const pos = new THREE.Vector3(position.x, position.y, position.z);
            return {
                min: local.min.clone().add(pos),
                max: local.max.clone().add(pos)
            };
        }

        function checkCollision(x, y, z, brickType, rotation, excludeIds = []) {
            const excludes = Array.isArray(excludeIds) ? excludeIds : (excludeIds ? [excludeIds] : []);
            const testBrick = {
                id: 'temp',
                position: {x,y,z},
                type: brickType,
                rotation
            };

            const bounds = getWorldBounds({x, y, z}, brickType, rotation);
            const tolerance = 0.005;

            // Shrink bounds slightly for collision check
            const aMin = bounds.min.clone().addScalar(tolerance);
            const aMax = bounds.max.clone().subScalar(tolerance);

            // Use spatial grid to find candidates
            const candidates = spatialGrid.getNearbyBricks(testBrick, null);

            for (const id of candidates) {
                if (excludes.includes(id)) continue;
                const brick = gameState.bricks.find(b => b.id === id);
                if (!brick) continue;

                const bBounds = getWorldBounds(brick.position, brick.type, brick.rotation);
                const bMin = bBounds.min.clone().addScalar(tolerance);
                const bMax = bBounds.max.clone().subScalar(tolerance);

                const intersect = (
                    aMin.x < bMax.x && aMax.x > bMin.x &&
                    aMin.y < bMax.y && aMax.y > bMin.y &&
                    aMin.z < bMax.z && aMax.z > bMin.z
                );

                if (intersect) return true;
            }

            return false;
        }

        // ==================== BRICK OPERATIONS ====================
        function handleCanvasClick(event) {
            if (cameraState.isRotating || cameraState.isPanning) return;

            const result = getIntersection(event);

            switch (gameState.currentTool) {
                case 'place':
                    if (result) placeBrick(result);
                    break;
                case 'select':
                    handleSelection(event, result);
                    break;
                case 'paint':
                    if (result && result.type === 'brick') {
                        paintBrick(result.brickId);
                    }
                    break;
                case 'delete':
                    if (result && result.type === 'brick') {
                        deleteBrick(result.brickId);
                    }
                    break;
            }
        }

        function placeBrick(result) {
            const brickType = gameState.currentBrickType;
            const rotation = { ...gameState.currentRotation };

            const point = result.intersection.point;
            const snapped = snapPosition(point, brickType, rotation);

            let y = 0;
            if (result.type === 'brick') {
                const hitBrick = gameState.bricks.find(b => b.id === result.brickId);
                if (hitBrick) {
                    const bBounds = getWorldBounds(hitBrick.position, hitBrick.type, hitBrick.rotation);
                    y = bBounds.max.y;
                }
            }

            const local = getLocalBounds(brickType, rotation);
            const placementY = y - local.min.y;

            // Check for collision
            if (!gameState.cheats.noClip && checkCollision(snapped.x, placementY, snapped.z, brickType, rotation)) {
                showToast('Cannot place here - collision!');
                return;
            }

            // Boundary check
            const halfGrid = CONFIG.gridSize / 2;
            if (Math.abs(snapped.x) > halfGrid || Math.abs(snapped.z) > halfGrid) {
                showToast('Outside building area!');
                return;
            }

            const brick = {
                id: generateId(),
                type: { ...brickType },
                position: { x: snapped.x, y: placementY, z: snapped.z },
                rotation: rotation,
                color: gameState.currentColor
            };

            gameState.bricks.push(brick);
            renderManager.addBrick(brick);
            spatialGrid.add(brick);

            saveToHistory();
            updateInfo();
        }

        function handleSelection(event, result) {
            const isShift = event.shiftKey;

            if (!result || result.type === 'ground') {
                if (!isShift) deselectAll();
                return;
            }

            const brickId = result.brickId;
            if (!brickId) return;

            if (isShift) {
                toggleSelection(brickId);
            } else {
                deselectAll();
                selectBrick(brickId);
            }

            updateInfo();
        }

        function selectBrick(id) {
            if (!gameState.selectedBrickIds.includes(id)) {
                gameState.selectedBrickIds.push(id);
                // Get brick
                const brick = gameState.bricks.find(b => b.id === id);
                if (brick) renderManager.addHighlight(brick);
            }
        }

        function deselectBrick(id) {
            const index = gameState.selectedBrickIds.indexOf(id);
            if (index > -1) {
                gameState.selectedBrickIds.splice(index, 1);
                renderManager.removeHighlight(id);
            }
        }

        function toggleSelection(id) {
            if (gameState.selectedBrickIds.includes(id)) {
                deselectBrick(id);
            } else {
                selectBrick(id);
            }
        }

        function deselectAll() {
            gameState.selectedBrickIds.forEach(id => renderManager.removeHighlight(id));
            gameState.selectedBrickIds = [];
            updateInfo();
        }

        function paintBrick(brickId) {
            const brick = gameState.bricks.find(b => b.id === brickId);
            if (brick) {
                brick.color = gameState.currentColor;
                renderManager.updateBrickColor(brick);
                saveToHistory();
                showToast('Color applied');
            }
        }

        function deleteBrick(id) {
            const index = gameState.bricks.findIndex(b => b.id === id);
            if (index > -1) {
                const brick = gameState.bricks[index];
                spatialGrid.remove(brick);
                renderManager.removeBrick(id);
                gameState.bricks.splice(index, 1);

                deselectBrick(id);
                applyGravity();
                saveToHistory();
                updateInfo();
            }
        }

        function deleteSelectedBricks() {
            if (gameState.selectedBrickIds.length === 0) {
                showToast('No bricks selected');
                return;
            }

            const count = gameState.selectedBrickIds.length;
            const idsToDelete = [...gameState.selectedBrickIds];
            idsToDelete.forEach(id => {
                const index = gameState.bricks.findIndex(b => b.id === id);
                if (index > -1) {
                    const brick = gameState.bricks[index];
                    spatialGrid.remove(brick);
                    renderManager.removeBrick(id);
                    gameState.bricks.splice(index, 1);
                }
            });

            gameState.selectedBrickIds = [];
            renderManager.selectionMeshes.forEach((mesh, id) => {
                if (idsToDelete.includes(id)) renderManager.removeHighlight(id);
            });

            applyGravity();
            saveToHistory();
            updateInfo();
            showToast(`Deleted ${count} brick(s)`);
        }

        function applyGravity() {
            // Sort by Y position (lowest first)
            gameState.bricks.sort((a, b) => a.position.y - b.position.y);

            let changed = false;

            for (const brick of gameState.bricks) {
                const newY = findSupportLevel(brick);
                if (Math.abs(newY - brick.position.y) > 0.01) {
                    // Update spatial grid: remove old, add new
                    spatialGrid.remove(brick);
                    brick.position.y = newY;
                    spatialGrid.add(brick);

                    renderManager.updateBrickTransformation(brick);

                    // Update highlight if selected
                    if (gameState.selectedBrickIds.includes(brick.id)) {
                        renderManager.removeHighlight(brick.id);
                        renderManager.addHighlight(brick);
                    }

                    changed = true;
                }
            }

            return changed;
        }

        function findSupportLevel(brick) {
            const local = getLocalBounds(brick.type, brick.rotation);
            const bounds = getWorldBounds(brick.position, brick.type, brick.rotation);
            const tolerance = 0.005;

            const aMinX = bounds.min.x + tolerance;
            const aMaxX = bounds.max.x - tolerance;
            const aMinZ = bounds.min.z + tolerance;
            const aMaxZ = bounds.max.z - tolerance;

            const bottomOffset = local.min.y;
            const currentBottomY = brick.position.y + bottomOffset;

            let maxSupportY = 0;

            // Optimization: Use spatial grid to check only nearby bricks
            const candidates = spatialGrid.getNearbyBricks(brick);

            for (const id of candidates) {
                const other = gameState.bricks.find(b => b.id === id);
                if (!other) continue;

                const bBounds = getWorldBounds(other.position, other.type, other.rotation);

                const overlapX = aMinX < bBounds.max.x && aMaxX > bBounds.min.x;
                const overlapZ = aMinZ < bBounds.max.z && aMaxZ > bBounds.min.z;

                if (overlapX && overlapZ) {
                     if (bBounds.max.y <= currentBottomY + 0.1) {
                        maxSupportY = Math.max(maxSupportY, bBounds.max.y);
                    }
                }
            }

            return maxSupportY - bottomOffset;
        }

        // ==================== ROTATION ====================
        function rotateAxis(axis, delta = 90) {
            gameState.currentRotation[axis] = ((gameState.currentRotation[axis] + delta) % 360 + 360) % 360;
            updateGhostBrick();

            // Also rotate selected bricks
            if (gameState.selectedBrickIds.length > 0) {
                const candidates = [];
                let isBlocked = false;

                // 1. Prepare candidates
                for (const id of gameState.selectedBrickIds) {
                    const brick = gameState.bricks.find(b => b.id === id);
                    if (brick) {
                        const newRot = { ...brick.rotation };
                        newRot[axis] = ((newRot[axis] + delta) % 360 + 360) % 360;
                        candidates.push({ brick, newRot });
                    }
                }

                // 2. Check collisions
                for (const cand of candidates) {
                    // Check against unselected bricks
                    if (checkCollision(cand.brick.position.x, cand.brick.position.y, cand.brick.position.z, cand.brick.type, cand.newRot, gameState.selectedBrickIds)) {
                        isBlocked = true;
                        break;
                    }

                    // Check against other candidates
                    const aBounds = getWorldBounds(cand.brick.position, cand.brick.type, cand.newRot);
                    const tolerance = 0.005;
                    const aMin = aBounds.min.clone().addScalar(tolerance);
                    const aMax = aBounds.max.clone().subScalar(tolerance);

                    for (const otherCand of candidates) {
                        if (otherCand.brick.id === cand.brick.id) continue;

                        const bBounds = getWorldBounds(otherCand.brick.position, otherCand.brick.type, otherCand.newRot);
                        const bMin = bBounds.min.clone().addScalar(tolerance);
                        const bMax = bBounds.max.clone().subScalar(tolerance);

                        const intersect = (
                            aMin.x < bMax.x && aMax.x > bMin.x &&
                            aMin.y < bMax.y && aMax.y > bMin.y &&
                            aMin.z < bMax.z && aMax.z > bMin.z
                        );

                        if (intersect) {
                            isBlocked = true;
                            break;
                        }
                    }
                    if (isBlocked) break;
                }

                if (isBlocked) {
                    showToast("Rotation blocked by collision");
                    return;
                }

                // 3. Apply rotation
                candidates.forEach(cand => {
                    cand.brick.rotation = cand.newRot;
                    renderManager.updateBrickTransformation(cand.brick);
                    // Update highlight
                    renderManager.removeHighlight(cand.brick.id);
                    renderManager.addHighlight(cand.brick);
                });
                saveToHistory();
            }
        }

        function resetRotation() {
            gameState.currentRotation = { x: 0, y: 0, z: 0 };
            updateGhostBrick();
            showToast('Rotation reset');
        }

        function updateRotationDisplay() {
            document.getElementById('rot-x').textContent = gameState.currentRotation.x + '¬∞';
            document.getElementById('rot-y').textContent = gameState.currentRotation.y + '¬∞';
            document.getElementById('rot-z').textContent = gameState.currentRotation.z + '¬∞';
        }

        // ==================== HISTORY ====================
        function saveToHistory() {
            // Truncate future history if we're not at the end
            if (gameState.historyIndex < gameState.history.length - 1) {
                gameState.history = gameState.history.slice(0, gameState.historyIndex + 1);
            }

            // Deep clone current state
            const state = JSON.stringify(gameState.bricks.map(b => ({
                id: b.id,
                type: b.type,
                position: { ...b.position },
                rotation: { ...b.rotation },
                color: b.color
            })));

            gameState.history.push(state);

            if (gameState.history.length > CONFIG.maxHistory) {
                gameState.history.shift();
            } else {
                gameState.historyIndex++;
            }
        }

        function undo() {
            if (gameState.historyIndex > 0) {
                gameState.historyIndex--;
                restoreFromHistory();
                showToast('Undo');
            } else {
                showToast('Nothing to undo');
            }
        }

        function redo() {
            if (gameState.historyIndex < gameState.history.length - 1) {
                gameState.historyIndex++;
                restoreFromHistory();
                showToast('Redo');
            } else {
                showToast('Nothing to redo');
            }
        }

        function restoreFromHistory() {
            const state = JSON.parse(gameState.history[gameState.historyIndex]);

            // Clear render manager and spatial grid
            renderManager.clear();
            spatialGrid.clear();
            gameState.bricks = [];
            gameState.selectedBrickIds = [];

            // Restore bricks
            state.forEach(brick => {
                 gameState.bricks.push(brick);
                 renderManager.addBrick(brick);
                 spatialGrid.add(brick);
            });

            updateInfo();
        }

        // ==================== SAVE/LOAD ====================
        function toggleSaveModal() {
            const modal = document.getElementById('save-modal');
            if (modal.classList.contains('show')) {
                closeModal('save-modal');
            } else {
                updateSaveList();
                modal.classList.add('show');
            }
        }

        function saveProjectCurrent() {
            const name = prompt('Enter a name for your build:', 'My LEGO Creation');
            if (!name || name.trim() === '') return;

            saveProject(name.trim());
        }

        function saveProject(name) {
            const saveData = {
                name: name,
                timestamp: Date.now(),
                bricks: gameState.bricks.map(b => ({
                    type: b.type,
                    position: b.position,
                    rotation: b.rotation,
                    color: b.color
                }))
            };

            try {
                let saves = JSON.parse(localStorage.getItem('legoBuilderSaves') || '[]');
                saves.push(saveData);

                // No limit on saves? maybe 20
                if (saves.length > 20) {
                    saves.shift(); // Remove oldest
                }

                localStorage.setItem('legoBuilderSaves', JSON.stringify(saves));
                showToast(`Saved: ${name}`);
                updateSaveList();
            } catch (e) {
                console.error(e);
                showToast('Error saving - storage may be full');
            }
        }

        function updateSaveList() {
             const list = document.getElementById('save-list');
             list.innerHTML = '';

             let saves = [];
             try {
                saves = JSON.parse(localStorage.getItem('legoBuilderSaves') || '[]');
             } catch(e) {}

             if (saves.length === 0) {
                 list.innerHTML = '<div style="color: #94a3b8; text-align: center; padding: 20px;">No saved builds</div>';
                 return;
             }

             saves.slice().reverse().forEach((save, index) => {
                 // Index in original array
                 const originalIndex = saves.length - 1 - index;

                 const item = document.createElement('div');
                 item.className = 'save-item';

                 const date = new Date(save.timestamp).toLocaleString();

                 item.innerHTML = `
                    <div class="save-item-info">
                        <div class="save-name">${escapeHtml(save.name)}</div>
                        <div class="save-date">${date} ‚Ä¢ ${save.bricks.length} bricks</div>
                    </div>
                    <div class="save-actions">
                        <button class="save-btn-action load-btn" onclick="loadProject(${originalIndex})">Load</button>
                        <button class="save-btn-action delete-btn" onclick="deleteSave(${originalIndex})">Delete</button>
                    </div>
                 `;
                 list.appendChild(item);
             });
        }

        function loadProject(index) {
             let saves = [];
             try {
                saves = JSON.parse(localStorage.getItem('legoBuilderSaves') || '[]');
             } catch(e) {}

             if (saves[index]) {
                 if (confirm('Load this build? Current unsaved progress will be lost.')) {
                     const save = saves[index];

                     renderManager.clear();
                     spatialGrid.clear();
                     gameState.bricks = [];
                     gameState.selectedBrickIds = [];
                     gameState.history = [];
                     gameState.historyIndex = -1;

                     save.bricks.forEach(b => {
                         // Ensure ID is generated if missing (older saves)
                         const brick = { ...b, id: generateId() };
                         gameState.bricks.push(brick);
                         renderManager.addBrick(brick);
                         spatialGrid.add(brick);
                     });

                     saveToHistory();
                     updateInfo();
                     closeModal('save-modal');
                     showToast(`Loaded: ${save.name}`);
                 }
             }
        }

        function deleteSave(index) {
            if (confirm('Delete this saved build?')) {
                 let saves = [];
                 try {
                    saves = JSON.parse(localStorage.getItem('legoBuilderSaves') || '[]');
                 } catch(e) {}

                 saves.splice(index, 1);
                 localStorage.setItem('legoBuilderSaves', JSON.stringify(saves));
                 updateSaveList();
            }
        }

        // ==================== NEW FEATURES ====================
        function cloneSelected() {
            if (gameState.selectedBrickIds.length === 0) {
                showToast('No bricks selected');
                return;
            }

            const newBricks = [];
            const newSelection = [];

            // Calculate offset (e.g. 1 unit in X)
            const offsetX = CONFIG.studSize * 2; // 1 unit
            const offsetZ = CONFIG.studSize * 2;

            gameState.selectedBrickIds.forEach(id => {
                const original = gameState.bricks.find(b => b.id === id);
                if (original) {
                    const newBrick = {
                        id: generateId(),
                        type: { ...original.type },
                        position: {
                            x: original.position.x + offsetX,
                            y: original.position.y,
                            z: original.position.z + offsetZ
                        },
                        rotation: { ...original.rotation },
                        color: original.color
                    };

                    newBricks.push(newBrick);
                    newSelection.push(newBrick.id);
                }
            });

            // Deselect originals
            deselectAll();

            // Add new bricks
            newBricks.forEach(brick => {
                gameState.bricks.push(brick);
                renderManager.addBrick(brick);
                spatialGrid.add(brick);
            });

            // Select new bricks
            newSelection.forEach(id => selectBrick(id));

            saveToHistory();
            updateInfo();
            showToast(`Cloned ${newBricks.length} bricks`);
        }

        function toggleGrid() {
            const gridHelper = scene.children.find(c => c instanceof THREE.GridHelper);
            if (gridHelper) {
                gridHelper.visible = !gridHelper.visible;
                showToast(`Grid ${gridHelper.visible ? 'Show' : 'Hidden'}`);
            }
        }

        let isNightMode = false;
        function toggleTheme() {
            isNightMode = !isNightMode;
            if (isNightMode) {
                // Night
                scene.background.setHex(0x050505);
                scene.fog.color.setHex(0x050505);
                document.body.style.background = '#020617';
            } else {
                // Default (Dark Blue)
                scene.background.setHex(0x1a2634);
                scene.fog.color.setHex(0x1a2634);
                document.body.style.background = '#0f172a';
            }
             showToast(isNightMode ? 'Night Mode' : 'Day Mode');
        }

        function selectAll() {
            deselectAll();
            gameState.bricks.forEach(b => {
                gameState.selectedBrickIds.push(b.id);
                renderManager.addHighlight(b);
            });
            updateInfo();
            showToast('Selected All');
        }

        function clearAll(showConfirm = true) {
            if (showConfirm && gameState.bricks.length > 0) {
                if (!confirm('Clear all bricks? This cannot be undone.')) return;
            }

            renderManager.clear();
            spatialGrid.clear();

            gameState.bricks = [];
            gameState.selectedBrickIds = [];
            gameState.history = [];
            gameState.historyIndex = -1;

            saveToHistory();
            updateInfo();

            if (showConfirm) showToast('All bricks cleared');
        }

        function exportScreenshot() {
            renderer.render(scene, camera);

            try {
                const dataURL = renderer.domElement.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'lego-creation-' + Date.now() + '.png';
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showToast('Screenshot exported!');
            } catch (e) {
                showToast('Export failed');
            }
        }

        // ==================== UI SETUP ====================
        function setupUI() {
            // Brick inventory
            const inventory = document.getElementById('brick-inventory');
            CONFIG.brickTypes.forEach((brick, index) => {
                const btn = document.createElement('button');
                btn.className = 'brick-btn' + (index === 0 ? ' selected' : '');
                btn.textContent = brick.name;
                btn.title = brick.name;
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.brick-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    gameState.currentBrickType = brick;
                    document.getElementById('current-brick').textContent = brick.name;
                    updateGhostBrick();
                });
                inventory.appendChild(btn);
            });

            // Color palette
            const palette = document.getElementById('color-palette');
            CONFIG.colors.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch' + (index === 0 ? ' selected' : '');
                swatch.style.backgroundColor = color.hex;
                swatch.title = color.name;
                swatch.addEventListener('click', () => {
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                    gameState.currentColor = color.hex;
                    updateGhostBrick();
                });
                palette.appendChild(swatch);
            });

            // Tool buttons
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.currentTool = btn.dataset.tool;

                    const toolName = btn.textContent.charAt(0).toUpperCase() + btn.textContent.slice(1);
                    document.getElementById('current-tool-header').textContent = toolName;

                    if (ghostBrick) {
                        ghostBrick.visible = false;
                    }
                });
            });

            // Rotation buttons
            document.getElementById('rotate-x').addEventListener('click', () => rotateAxis('x'));
            document.getElementById('rotate-y').addEventListener('click', () => rotateAxis('y'));
            document.getElementById('rotate-z').addEventListener('click', () => rotateAxis('z'));
            document.getElementById('reset-rotation').addEventListener('click', resetRotation);

            // Action buttons
            document.getElementById('undo-btn').addEventListener('click', undo);
            document.getElementById('redo-btn').addEventListener('click', redo);
            // Update Save button listener to toggle modal
            document.getElementById('save-btn').addEventListener('click', toggleSaveModal);
            document.getElementById('clone-btn').addEventListener('click', cloneSelected);
            document.getElementById('export-btn').addEventListener('click', exportScreenshot);
            document.getElementById('grid-btn').addEventListener('click', toggleGrid);
            document.getElementById('theme-btn').addEventListener('click', toggleTheme);
            document.getElementById('select-all-btn').addEventListener('click', selectAll);
            document.getElementById('clear-btn').addEventListener('click', () => clearAll(true));

            // Cheats
            document.getElementById('cheat-noclip').addEventListener('click', () => {
                gameState.cheats.noClip = !gameState.cheats.noClip;
                const btn = document.getElementById('cheat-noclip');
                if (gameState.cheats.noClip) {
                    btn.classList.add('active');
                    showToast('Ghost Mode Enabled (No Clip)');
                } else {
                    btn.classList.remove('active');
                    showToast('Ghost Mode Disabled');
                }
            });

            document.getElementById('cheat-random').addEventListener('click', () => {
                const targets = gameState.selectedBrickIds.length > 0 ?
                    gameState.selectedBrickIds :
                    gameState.bricks.map(b => b.id);

                if (targets.length === 0) {
                    showToast('No bricks to randomize');
                    return;
                }

                targets.forEach(id => {
                    const brick = gameState.bricks.find(b => b.id === id);
                    if (brick) {
                        const randomColor = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)].hex;
                        brick.color = randomColor;
                        renderManager.updateBrickColor(brick);
                    }
                });
                saveToHistory();
                showToast(`Randomized ${targets.length} bricks!`);
            });
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch (e.key) {
                    case 'Delete':
                    case 'Backspace':
                        e.preventDefault();
                        deleteSelectedBricks();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        rotateAxis('x', 90);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        rotateAxis('x', -90);
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        rotateAxis('y', 90);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        rotateAxis('y', -90);
                        break;
                    case 'q':
                    case 'Q':
                        e.preventDefault();
                        rotateAxis('z', 90);
                        break;
                    case 'e':
                    case 'E':
                        e.preventDefault();
                        rotateAxis('z', -90);
                        break;
                    case 'z':
                    case 'Z':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            if (e.shiftKey) {
                                redo();
                            } else {
                                undo();
                            }
                        }
                        break;
                    case 'y':
                    case 'Y':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            redo();
                        }
                        break;
                    case 'Escape':
                        deselectAll();
                        closeModal('save-modal');
                        break;
                }
            });
        }

        // ==================== UTILITIES ====================
        function generateId() {
            return 'brick_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');

            clearTimeout(toast.hideTimeout);
            toast.hideTimeout = setTimeout(() => {
                toast.classList.remove('show');
            }, 2500);
        }

        function closeModal(id) {
            document.getElementById(id).classList.remove('show');
        }

        function updateInfo() {
            document.getElementById('brick-count').textContent = gameState.bricks.length;
            document.getElementById('brick-count-header').textContent = gameState.bricks.length;
            document.getElementById('selected-count').textContent = gameState.selectedBrickIds.length;
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // ==================== START ====================
        window.addEventListener('load', init);
    </script>
</body>
</html>
