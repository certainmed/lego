<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEGO Builder</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background: #0f172a;
            color: #e2e8f0;
        }

        /* Floating Header */
        #header {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            display: flex;
            align-items: center;
            gap: 24px;
            z-index: 100;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        #header h1 {
            color: #fff;
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(135deg, #f43f5e 0%, #e11d48 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-info {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: #94a3b8;
        }

        .header-info strong {
            color: #f8fafc;
            font-weight: 600;
        }

        /* Fullscreen Canvas */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
            z-index: 0;
        }

        /* Floating Control Panel */
        #control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            bottom: 20px;
            width: 320px;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            overflow-y: auto;
            padding: 20px;
            z-index: 100;
            box-shadow: -4px 0 30px rgba(0, 0, 0, 0.3);
            scrollbar-width: thin;
            scrollbar-color: #334155 transparent;
        }

        #control-panel::-webkit-scrollbar {
            width: 6px;
        }

        #control-panel::-webkit-scrollbar-thumb {
            background-color: #334155;
            border-radius: 3px;
        }

        .panel-section {
            margin-bottom: 24px;
        }

        .panel-section h3 {
            color: #94a3b8;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-section h3::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255,255,255,0.1);
        }

        /* Tool Buttons */
        .tool-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            background: rgba(0, 0, 0, 0.2);
            padding: 4px;
            border-radius: 12px;
        }

        .tool-btn {
            padding: 10px 4px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: #94a3b8;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: inherit;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
        }

        .tool-btn.active {
            background: #3b82f6;
            color: #fff;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        /* Action Buttons */
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .action-btn {
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            background: rgba(30, 41, 59, 0.5);
            color: #cbd5e1;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            font-family: inherit;
        }

        .action-btn:hover {
            background: #334155;
            color: #fff;
            border-color: rgba(255,255,255,0.1);
            transform: translateY(-1px);
        }

        .action-btn:active {
            transform: translateY(0);
        }

        .action-btn.danger {
            background: rgba(220, 38, 38, 0.1);
            color: #f87171;
            border-color: rgba(220, 38, 38, 0.2);
        }

        .action-btn.danger:hover {
            background: rgba(220, 38, 38, 0.2);
            color: #fca5a5;
        }

        /* Brick Grid */
        .brick-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .brick-btn {
            padding: 12px 4px;
            border: 1px solid transparent;
            border-radius: 10px;
            background: #1e293b;
            color: #cbd5e1;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
            font-family: inherit;
        }

        .brick-btn:hover {
            background: #334155;
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .brick-btn.selected {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: #fff;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
            transform: translateY(-1px);
        }

        /* Color Palette */
        .color-palette {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid rgba(255,255,255,0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .color-swatch:hover {
            transform: scale(1.15);
            border-color: rgba(255,255,255,0.5);
            z-index: 10;
        }

        .color-swatch.selected {
            border-color: #fff;
            box-shadow: 0 0 0 2px rgba(15, 23, 42, 0.8), 0 0 0 4px #fff;
            transform: scale(1.1);
            z-index: 2;
        }

        /* Info & Rotation */
        #info-display {
            background: rgba(0,0,0,0.2);
            padding: 12px;
            border-radius: 12px;
            font-size: 12px;
            color: #94a3b8;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        #info-display span {
            color: #38bdf8;
            float: right;
        }

        .rotation-display {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            font-size: 11px;
            color: #94a3b8;
            font-family: monospace;
        }

        .rotation-display span {
            color: #f43f5e;
            font-weight: bold;
        }

        /* Toast */
        #toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(15, 23, 42, 0.9);
            color: #fff;
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 1000;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(12px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        #toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Modals */
        .modal-content {
            background: #1e293b;
            padding: 32px;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 500px;
        }

        .modal-content h2 {
            color: #fff;
            font-weight: 700;
            font-size: 24px;
            background: linear-gradient(135deg, #fff 0%, #94a3b8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .shortcut {
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding: 12px 0;
            color: #cbd5e1;
        }

        .key {
            background: #334155;
            color: #38bdf8;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
            font-weight: 600;
        }

        .close-modal {
            background: #3b82f6;
            color: #fff;
            padding: 12px;
            border-radius: 12px;
            font-weight: 600;
            margin-top: 24px;
            transition: all 0.2s;
        }

        .close-modal:hover {
            background: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(37, 99, 235, 0.3);
        }

        .save-item {
            background: #334155;
            border-radius: 12px;
            margin-bottom: 8px;
            border: 1px solid transparent;
        }

        .save-item:hover {
            background: #475569;
            border-color: #64748b;
        }

        .save-item-delete {
            background: rgba(220, 38, 38, 0.2);
            color: #fca5a5;
        }

        .save-item-delete:hover {
            background: rgba(220, 38, 38, 0.4);
        }
</style>
</head>
<body>
    <div id="header">
        <h1>ðŸ§± LEGO Builder</h1>
        <div class="header-info">
            <span>Bricks: <strong id="brick-count-header">0</strong></span>
            <span>Tool: <strong id="current-tool-header">Place</strong></span>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="control-panel">
        <div class="panel-section">
            <h3>ðŸ”§ Tools</h3>
            <div class="tool-buttons">
                <button class="tool-btn active" data-tool="place" title="Place bricks">Place</button>
                <button class="tool-btn" data-tool="select" title="Select bricks">Select</button>
                <button class="tool-btn" data-tool="paint" title="Paint bricks">Paint</button>
                <button class="tool-btn" data-tool="delete" title="Delete bricks">Delete</button>
            </div>
        </div>

        <div class="panel-section">
            <h3>ðŸ§± Brick Type</h3>
            <div class="brick-grid" id="brick-inventory"></div>
        </div>

        <div class="panel-section">
            <h3>ðŸŽ¨ Colors</h3>
            <div class="color-palette" id="color-palette"></div>
        </div>

        <div class="panel-section">
            <h3>ðŸ”„ Rotation</h3>
            <div class="tool-buttons">
                <button class="action-btn" id="rotate-x" title="Rotate around X axis">X +90Â°</button>
                <button class="action-btn" id="rotate-y" title="Rotate around Y axis">Y +90Â°</button>
                <button class="action-btn" id="rotate-z" title="Rotate around Z axis">Z +90Â°</button>
                <button class="action-btn" id="reset-rotation" title="Reset rotation">Reset</button>
            </div>
            <div class="rotation-display">
                <div>X: <span id="rot-x">0Â°</span></div>
                <div>Y: <span id="rot-y">0Â°</span></div>
                <div>Z: <span id="rot-z">0Â°</span></div>
            </div>
        </div>

        <div class="panel-section">
            <h3>âš¡ Actions</h3>
            <div class="action-buttons">
                <button class="action-btn" id="undo-btn" title="Undo (Ctrl+Z)">â†© Undo</button>
                <button class="action-btn" id="redo-btn" title="Redo (Ctrl+Y)">â†ª Redo</button>
                <button class="action-btn" id="duplicate-btn" title="Duplicate selected">ðŸ“‘ Duplicate</button>
                <button class="action-btn" id="toggle-grid-btn" title="Toggle Grid">â–¦ Grid</button>
                <button class="action-btn" id="export-btn" title="Export screenshot">ðŸ“¸ Export</button>
                <button class="action-btn" id="reset-camera" title="Reset camera view">ðŸŽ¥ Camera</button>
                <button class="action-btn danger" id="clear-btn" title="Clear all bricks">ðŸ—‘ Clear</button>
            </div>
        </div>

        <div class="panel-section">
            <h3>ðŸ“Š Info</h3>
            <div id="info-display">
                <div>Total Bricks: <span id="brick-count">0</span></div>
                <div>Selected: <span id="selected-count">0</span></div>
                <div>Current Brick: <span id="current-brick">1Ã—1</span></div>
            </div>
        </div>
    </div>

    <div id="toast"></div>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            gridSize: 20,
            studSize: 0.5,
            plateHeight: 0.33,
            brickHeight: 1.0,
            maxHistory: 50,
            colors: [
                { name: 'Red', hex: '#e63946' },
                { name: 'Blue', hex: '#2660a4' },
                { name: 'Green', hex: '#2a9d8f' },
                { name: 'Yellow', hex: '#ffd60a' },
                { name: 'White', hex: '#f8f9fa' },
                { name: 'Black', hex: '#1a1a1a' },
                { name: 'Orange', hex: '#fb8500' },
                { name: 'Purple', hex: '#7b2cbf' },
                { name: 'Pink', hex: '#ff69b4' },
                { name: 'Cyan', hex: '#00b4d8' },
                { name: 'Brown', hex: '#8b5a2b' },
                { name: 'Gray', hex: '#6c757d' }
            ],
            brickTypes: [
                { id: '1x1', name: '1Ã—1', width: 1, depth: 1, type: 'brick' },
                { id: '1x2', name: '1Ã—2', width: 1, depth: 2, type: 'brick' },
                { id: '1x4', name: '1Ã—4', width: 1, depth: 4, type: 'brick' },
                { id: '2x2', name: '2Ã—2', width: 2, depth: 2, type: 'brick' },
                { id: '2x4', name: '2Ã—4', width: 2, depth: 4, type: 'brick' },
                { id: '2x6', name: '2Ã—6', width: 2, depth: 6, type: 'brick' },
                { id: '1x1p', name: '1Ã—1 Plt', width: 1, depth: 1, type: 'plate' },
                { id: '2x2p', name: '2Ã—2 Plt', width: 2, depth: 2, type: 'plate' },
                { id: '2x4p', name: '2Ã—4 Plt', width: 2, depth: 4, type: 'plate' }
            ]
        };

        // ==================== GAME STATE ====================
        let gameState = {
            bricks: [],
            selectedBrickIds: [],
            history: [],
            historyIndex: -1,
            currentTool: 'place',
            currentBrickType: CONFIG.brickTypes[0],
            currentColor: CONFIG.colors[0].hex,
            currentRotation: { x: 0, y: 0, z: 0 }
        };

        // ==================== THREE.JS VARIABLES ====================
        let scene, camera, renderer;
        let ghostBrick = null;
        let brickMeshes = new Map();
        let groundPlane;

        // Camera control state
        let cameraState = {
            isRotating: false,
            isPanning: false,
            lastMouseX: 0,
            lastMouseY: 0,
            theta: Math.PI / 4,
            phi: Math.PI / 3,
            radius: 20,
            target: new THREE.Vector3(0, 0, 0)
        };

        // ==================== INITIALIZATION ====================
        function init() {
            initThree();
            setupUI();
            setupKeyboardShortcuts();
            saveToHistory();
            updateInfo();
            showToast('Welcome to LEGO Builder! Click to place bricks.');
        }

        function initThree() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2634);
            scene.fog = new THREE.Fog(0x1a2634, 30, 80);

            // Camera
            camera = new THREE.PerspectiveCamera(
                55,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Lighting
            setupLighting();

            // Ground and Grid
            createGroundAndGrid();

            // Ghost brick preview
            createGhostBrick();

            // Camera controls
            setupCameraControls(container);

            // Initial camera position
            updateCameraPosition();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            container.addEventListener('click', handleCanvasClick);
            container.addEventListener('mousemove', handleMouseMove);

            // Start render loop
            animate();
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Main directional light
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(15, 25, 15);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 1;
            mainLight.shadow.camera.far = 60;
            mainLight.shadow.camera.left = -20;
            mainLight.shadow.camera.right = 20;
            mainLight.shadow.camera.top = 20;
            mainLight.shadow.camera.bottom = -20;
            mainLight.shadow.bias = -0.001;
            scene.add(mainLight);

            // Fill light
            const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);

            // Hemisphere light for ambient
            const hemiLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.3);
            scene.add(hemiLight);
        }

        function createGroundAndGrid() {
            // Ground plane
            const groundGeo = new THREE.PlaneGeometry(CONFIG.gridSize * 2, CONFIG.gridSize * 2);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x3d5a4c,
                roughness: 0.9,
                metalness: 0.1
            });
            groundPlane = new THREE.Mesh(groundGeo, groundMat);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = -0.01;
            groundPlane.receiveShadow = true;
            groundPlane.name = 'ground';
            scene.add(groundPlane);

            // Grid helper
            const gridHelper = new THREE.GridHelper(CONFIG.gridSize, CONFIG.gridSize * 2, 0x557755, 0x446644);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            // Axis indicator
            const axesHelper = new THREE.AxesHelper(3);
            axesHelper.position.set(-CONFIG.gridSize/2 + 1, 0.1, -CONFIG.gridSize/2 + 1);
            scene.add(axesHelper);
        }

        function createBrickGeometry(brickType, withRotation = null) {
            const effectiveType = { ...brickType };

            // Handle rotation swapping dimensions
            if (withRotation) {
                const yRot = ((withRotation.y % 360) + 360) % 360;
                if (yRot === 90 || yRot === 270) {
                    effectiveType.width = brickType.depth;
                    effectiveType.depth = brickType.width;
                }
            }

            const width = effectiveType.width * CONFIG.studSize;
            const depth = effectiveType.depth * CONFIG.studSize;
            const height = effectiveType.type === 'plate' ? CONFIG.plateHeight : CONFIG.brickHeight;

            const group = new THREE.Group();

            // Main body with slight bevel effect
            const bodyGeo = new THREE.BoxGeometry(width - 0.02, height - 0.02, depth - 0.02);
            const bodyMesh = new THREE.Mesh(bodyGeo);
            bodyMesh.position.y = height / 2;
            group.add(bodyMesh);

            // Add studs on top
            const studRadius = CONFIG.studSize * 0.3;
            const studHeight = 0.12;
            const studGeo = new THREE.CylinderGeometry(studRadius, studRadius * 1.05, studHeight, 12);

            for (let x = 0; x < brickType.width; x++) {
                for (let z = 0; z < brickType.depth; z++) {
                    const stud = new THREE.Mesh(studGeo);
                    stud.position.x = (x - (brickType.width - 1) / 2) * CONFIG.studSize;
                    stud.position.y = height + studHeight / 2 - 0.01;
                    stud.position.z = (z - (brickType.depth - 1) / 2) * CONFIG.studSize;
                    group.add(stud);
                }
            }

            // Merge into single geometry
            const mergedGeo = mergeGroupGeometry(group);
            return mergedGeo;
        }

        function mergeGroupGeometry(group) {
            const positions = [];
            const normals = [];
            const indices = [];
            let indexOffset = 0;

            group.updateMatrixWorld(true);

            group.children.forEach(child => {
                const geo = child.geometry.clone();
                geo.applyMatrix4(child.matrixWorld);

                const pos = geo.getAttribute('position');
                const norm = geo.getAttribute('normal');
                const idx = geo.getIndex();

                for (let i = 0; i < pos.count; i++) {
                    positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));
                    normals.push(norm.getX(i), norm.getY(i), norm.getZ(i));
                }

                if (idx) {
                    for (let i = 0; i < idx.count; i++) {
                        indices.push(idx.getX(i) + indexOffset);
                    }
                }

                indexOffset += pos.count;
            });

            const mergedGeo = new THREE.BufferGeometry();
            mergedGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            mergedGeo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            if (indices.length > 0) {
                mergedGeo.setIndex(indices);
            }
            mergedGeo.computeBoundingBox();

            return mergedGeo;
        }

        function createGhostBrick() {
            updateGhostBrick();
        }

        function updateGhostBrick() {
            if (ghostBrick) {
                scene.remove(ghostBrick);
                if (ghostBrick.geometry) ghostBrick.geometry.dispose();
                if (ghostBrick.material) ghostBrick.material.dispose();
            }

            const geometry = createBrickGeometry(gameState.currentBrickType);
            const material = new THREE.MeshStandardMaterial({
                color: gameState.currentColor,
                transparent: true,
                opacity: 0.6,
                roughness: 0.5
            });

            ghostBrick = new THREE.Mesh(geometry, material);
            ghostBrick.visible = false;
            ghostBrick.name = 'ghost';
            scene.add(ghostBrick);

            updateRotationDisplay();
        }

        // ==================== CAMERA CONTROLS ====================
        function setupCameraControls(container) {
            container.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    cameraState.isRotating = true;
                    cameraState.lastMouseX = e.clientX;
                    cameraState.lastMouseY = e.clientY;
                    e.preventDefault();
                } else if (e.button === 1) {
                    cameraState.isPanning = true;
                    cameraState.lastMouseX = e.clientX;
                    cameraState.lastMouseY = e.clientY;
                    e.preventDefault();
                }
            });

            container.addEventListener('mouseup', () => {
                cameraState.isRotating = false;
                cameraState.isPanning = false;
            });

            container.addEventListener('mouseleave', () => {
                cameraState.isRotating = false;
                cameraState.isPanning = false;
            });

            container.addEventListener('mousemove', (e) => {
                const deltaX = e.clientX - cameraState.lastMouseX;
                const deltaY = e.clientY - cameraState.lastMouseY;

                if (cameraState.isRotating) {
                    cameraState.theta -= deltaX * 0.008;
                    cameraState.phi = Math.max(0.2, Math.min(Math.PI / 2 - 0.1, cameraState.phi - deltaY * 0.008));
                    updateCameraPosition();
                }

                if (cameraState.isPanning) {
                    const panSpeed = 0.02;
                    cameraState.target.x -= deltaX * panSpeed;
                    cameraState.target.z -= deltaY * panSpeed;
                    updateCameraPosition();
                }

                cameraState.lastMouseX = e.clientX;
                cameraState.lastMouseY = e.clientY;
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraState.radius = Math.max(5, Math.min(50, cameraState.radius + e.deltaY * 0.03));
                updateCameraPosition();
            }, { passive: false });

            container.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function updateCameraPosition() {
            camera.position.x = cameraState.target.x + cameraState.radius * Math.sin(cameraState.phi) * Math.cos(cameraState.theta);
            camera.position.y = cameraState.target.y + cameraState.radius * Math.cos(cameraState.phi);
            camera.position.z = cameraState.target.z + cameraState.radius * Math.sin(cameraState.phi) * Math.sin(cameraState.theta);
            camera.lookAt(cameraState.target);
        }

        function resetCamera() {
            cameraState.theta = Math.PI / 4;
            cameraState.phi = Math.PI / 3;
            cameraState.radius = 20;
            cameraState.target.set(0, 0, 0);
            updateCameraPosition();
            showToast('Camera reset');
        }

        // ==================== RAYCASTING ====================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function getIntersection(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check bricks first
            const brickMeshArray = Array.from(brickMeshes.values());
            const brickIntersects = raycaster.intersectObjects(brickMeshArray);

            if (brickIntersects.length > 0) {
                return { type: 'brick', intersection: brickIntersects[0] };
            }

            // Check ground
            const groundIntersects = raycaster.intersectObject(groundPlane);
            if (groundIntersects.length > 0) {
                return { type: 'ground', intersection: groundIntersects[0] };
            }

            return null;
        }

        function handleMouseMove(event) {
            if (gameState.currentTool === 'place') {
                updateGhostPosition(event);
            } else if (ghostBrick) {
                ghostBrick.visible = false;
            }
        }

        function updateGhostPosition(event) {
            if (!ghostBrick) return;

            const result = getIntersection(event);

            if (result) {
                ghostBrick.visible = true;

                const point = result.intersection.point;
                const snapped = snapPosition(point, gameState.currentBrickType, gameState.currentRotation);

                let y = 0;
                if (result.type === 'brick') {
                    const hitBrick = getBrickByMesh(result.intersection.object);
                    if (hitBrick) {
                        const bBounds = getWorldBounds(hitBrick.position, hitBrick.type, hitBrick.rotation);
                        y = bBounds.max.y;
                    }
                }

                const local = getLocalBounds(gameState.currentBrickType, gameState.currentRotation);
                const placementY = y - local.min.y;

                ghostBrick.position.set(snapped.x, placementY, snapped.z);
                ghostBrick.rotation.set(
                    THREE.MathUtils.degToRad(gameState.currentRotation.x),
                    THREE.MathUtils.degToRad(gameState.currentRotation.y),
                    THREE.MathUtils.degToRad(gameState.currentRotation.z)
                );

                // Check collision and update color
                const hasCollision = checkCollision(snapped.x, placementY, snapped.z, gameState.currentBrickType, gameState.currentRotation);

                if (hasCollision) {
                    ghostBrick.material.color.setHex(0xff3333);
                    ghostBrick.material.opacity = 0.4;
                } else {
                    ghostBrick.material.color.set(gameState.currentColor);
                    ghostBrick.material.opacity = 0.6;
                }
            } else {
                ghostBrick.visible = false;
            }
        }

        function snapPosition(point, brickType, rotation) {
            const unit = CONFIG.studSize;

            // Determine effective dimensions after rotation
            let effWidth = brickType.width;
            let effDepth = brickType.depth;

            const yRot = ((rotation.y % 360) + 360) % 360;
            if (yRot === 90 || yRot === 270) {
                effWidth = brickType.depth;
                effDepth = brickType.width;
            }

            // Calculate offset for centering
            const offsetX = (effWidth % 2 === 0) ? 0 : unit / 2;
            const offsetZ = (effDepth % 2 === 0) ? 0 : unit / 2;

            return {
                x: Math.round((point.x - offsetX) / unit) * unit + offsetX,
                z: Math.round((point.z - offsetZ) / unit) * unit + offsetZ
            };
        }

        function getBrickHeight(type) {
            return type.type === 'plate' ? CONFIG.plateHeight : CONFIG.brickHeight;
        }

        function getEffectiveDimensions(brickType, rotation) {
            let width = brickType.width;
            let depth = brickType.depth;

            const yRot = ((rotation.y % 360) + 360) % 360;
            if (yRot === 90 || yRot === 270) {
                return { width: depth, depth: width };
            }
            return { width, depth };
        }

        function getLocalBounds(brickType, rotation) {
            const w = brickType.width * CONFIG.studSize;
            const h = brickType.type === 'plate' ? CONFIG.plateHeight : CONFIG.brickHeight;
            const d = brickType.depth * CONFIG.studSize;

            // Define corners relative to pivot (which is bottom-center of the unrotated brick)
            const min = new THREE.Vector3(-w/2, 0, -d/2);
            const max = new THREE.Vector3(w/2, h, d/2);

            const corners = [
                new THREE.Vector3(min.x, min.y, min.z),
                new THREE.Vector3(max.x, min.y, min.z),
                new THREE.Vector3(min.x, max.y, min.z),
                new THREE.Vector3(max.x, max.y, min.z),
                new THREE.Vector3(min.x, min.y, max.z),
                new THREE.Vector3(max.x, min.y, max.z),
                new THREE.Vector3(min.x, max.y, max.z),
                new THREE.Vector3(max.x, max.y, max.z)
            ];

            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(rotation.x),
                THREE.MathUtils.degToRad(rotation.y),
                THREE.MathUtils.degToRad(rotation.z),
                'XYZ'
            );

            const rotatedMin = new THREE.Vector3(Infinity, Infinity, Infinity);
            const rotatedMax = new THREE.Vector3(-Infinity, -Infinity, -Infinity);

            corners.forEach(p => {
                p.applyEuler(euler);
                rotatedMin.min(p);
                rotatedMax.max(p);
            });

            return { min: rotatedMin, max: rotatedMax };
        }

        function getWorldBounds(position, brickType, rotation) {
            const local = getLocalBounds(brickType, rotation);
            const pos = new THREE.Vector3(position.x, position.y, position.z);
            return {
                min: local.min.clone().add(pos),
                max: local.max.clone().add(pos)
            };
        }

        function checkCollision(x, y, z, brickType, rotation, excludeIds = []) {
            const excludes = Array.isArray(excludeIds) ? excludeIds : (excludeIds ? [excludeIds] : []);

            const bounds = getWorldBounds({x, y, z}, brickType, rotation);
            const tolerance = 0.005;

            // Shrink bounds slightly for collision check
            const aMin = bounds.min.clone().addScalar(tolerance);
            const aMax = bounds.max.clone().subScalar(tolerance);

            for (const brick of gameState.bricks) {
                if (excludes.includes(brick.id)) continue;

                const bBounds = getWorldBounds(brick.position, brick.type, brick.rotation);
                const bMin = bBounds.min.clone().addScalar(tolerance);
                const bMax = bBounds.max.clone().subScalar(tolerance);

                const intersect = (
                    aMin.x < bMax.x && aMax.x > bMin.x &&
                    aMin.y < bMax.y && aMax.y > bMin.y &&
                    aMin.z < bMax.z && aMax.z > bMin.z
                );

                if (intersect) return true;
            }

            return false;
        }

        function duplicateSelected() {
            if (gameState.selectedBrickIds.length === 0) {
                showToast('No bricks selected to duplicate');
                return;
            }

            const newBricks = [];
            const offset = 2; // Offset to avoid perfect overlap

            gameState.selectedBrickIds.forEach(id => {
                const original = gameState.bricks.find(b => b.id === id);
                if (original) {
                    const newBrick = {
                        id: generateId(),
                        type: { ...original.type },
                        position: {
                            x: original.position.x + offset,
                            y: original.position.y,
                            z: original.position.z + offset
                        },
                        rotation: { ...original.rotation },
                        color: original.color
                    };

                    // Simple boundary check for duplicate
                    const halfGrid = CONFIG.gridSize / 2;
                    if (Math.abs(newBrick.position.x) > halfGrid || Math.abs(newBrick.position.z) > halfGrid) {
                        newBrick.position.x = original.position.x;
                        newBrick.position.z = original.position.z;
                        newBrick.position.y += getBrickHeight(newBrick.type);
                    }

                    newBricks.push(newBrick);
                    gameState.bricks.push(newBrick);
                    createBrickMesh(newBrick);
                }
            });

            // Select new bricks
            deselectAll();
            newBricks.forEach(b => selectBrick(b.id));

            saveToHistory();
            updateInfo();
            showToast(`Duplicated ${newBricks.length} brick(s)`);
        }

        let isGridVisible = true;
        function toggleGrid() {
            isGridVisible = !isGridVisible;
            if (groundPlane) groundPlane.visible = isGridVisible;
            // We need to find the gridHelper. Since it wasn't global, we look for it in scene.children
            scene.children.forEach(child => {
                if (child.type === 'GridHelper' || child.type === 'AxesHelper') {
                    child.visible = isGridVisible;
                }
            });
            showToast(`Grid: ${isGridVisible ? 'On' : 'Off'}`);
        }

        // ==================== BRICK OPERATIONS ====================
        function handleCanvasClick(event) {
            if (cameraState.isRotating || cameraState.isPanning) return;

            const result = getIntersection(event);

            switch (gameState.currentTool) {
                case 'place':
                    if (result) placeBrick(result);
                    break;
                case 'select':
                    handleSelection(event, result);
                    break;
                case 'paint':
                    if (result && result.type === 'brick') {
                        paintBrick(result.intersection.object);
                    }
                    break;
                case 'delete':
                    if (result && result.type === 'brick') {
                        deleteBrickByMesh(result.intersection.object);
                    }
                    break;
            }
        }

        function placeBrick(result) {
            const brickType = gameState.currentBrickType;
            const rotation = { ...gameState.currentRotation };

            const point = result.intersection.point;
            const snapped = snapPosition(point, brickType, rotation);

            let y = 0;
            if (result.type === 'brick') {
                const hitBrick = getBrickByMesh(result.intersection.object);
                if (hitBrick) {
                    const bBounds = getWorldBounds(hitBrick.position, hitBrick.type, hitBrick.rotation);
                    y = bBounds.max.y;
                }
            }

            const local = getLocalBounds(brickType, rotation);
            const placementY = y - local.min.y;

            // Check for collision
            if (checkCollision(snapped.x, placementY, snapped.z, brickType, rotation)) {
                showToast('Cannot place here - collision!');
                return;
            }

            // Boundary check
            const halfGrid = CONFIG.gridSize / 2;
            if (Math.abs(snapped.x) > halfGrid || Math.abs(snapped.z) > halfGrid) {
                showToast('Outside building area!');
                return;
            }

            const brick = {
                id: generateId(),
                type: { ...brickType },
                position: { x: snapped.x, y: placementY, z: snapped.z },
                rotation: rotation,
                color: gameState.currentColor
            };

            gameState.bricks.push(brick);
            createBrickMesh(brick);
            saveToHistory();
            updateInfo();
        }

        function createBrickMesh(brick) {
            const geometry = createBrickGeometry(brick.type);
            const material = new THREE.MeshStandardMaterial({
                color: brick.color,
                roughness: 0.35,
                metalness: 0.05
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(brick.position.x, brick.position.y, brick.position.z);
            mesh.rotation.set(
                THREE.MathUtils.degToRad(brick.rotation.x),
                THREE.MathUtils.degToRad(brick.rotation.y),
                THREE.MathUtils.degToRad(brick.rotation.z)
            );
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.brickId = brick.id;

            scene.add(mesh);
            brickMeshes.set(brick.id, mesh);
        }

        function getBrickByMesh(mesh) {
            const id = mesh.userData.brickId;
            return gameState.bricks.find(b => b.id === id);
        }

        function handleSelection(event, result) {
            const isShift = event.shiftKey;

            if (!result || result.type === 'ground') {
                if (!isShift) deselectAll();
                return;
            }

            const brick = getBrickByMesh(result.intersection.object);
            if (!brick) return;

            if (isShift) {
                toggleSelection(brick.id);
            } else {
                deselectAll();
                selectBrick(brick.id);
            }

            updateInfo();
        }

        function selectBrick(id) {
            if (!gameState.selectedBrickIds.includes(id)) {
                gameState.selectedBrickIds.push(id);
                updateBrickHighlight(id, true);
            }
        }

        function deselectBrick(id) {
            const index = gameState.selectedBrickIds.indexOf(id);
            if (index > -1) {
                gameState.selectedBrickIds.splice(index, 1);
                updateBrickHighlight(id, false);
            }
        }

        function toggleSelection(id) {
            if (gameState.selectedBrickIds.includes(id)) {
                deselectBrick(id);
            } else {
                selectBrick(id);
            }
        }

        function deselectAll() {
            gameState.selectedBrickIds.forEach(id => updateBrickHighlight(id, false));
            gameState.selectedBrickIds = [];
            updateInfo();
        }

        function updateBrickHighlight(id, isSelected) {
            const mesh = brickMeshes.get(id);
            if (mesh) {
                if (isSelected) {
                    mesh.material.emissive = new THREE.Color(0xffaa00);
                    mesh.material.emissiveIntensity = 0.4;
                } else {
                    mesh.material.emissive = new THREE.Color(0x000000);
                    mesh.material.emissiveIntensity = 0;
                }
            }
        }

        function paintBrick(mesh) {
            const brick = getBrickByMesh(mesh);
            if (brick) {
                brick.color = gameState.currentColor;
                mesh.material.color.set(gameState.currentColor);
                saveToHistory();
                showToast('Color applied');
            }
        }

        function deleteBrickByMesh(mesh) {
            const brick = getBrickByMesh(mesh);
            if (brick) deleteBrick(brick.id);
        }

        function deleteBrick(id) {
            const index = gameState.bricks.findIndex(b => b.id === id);
            if (index > -1) {
                gameState.bricks.splice(index, 1);

                const mesh = brickMeshes.get(id);
                if (mesh) {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                    brickMeshes.delete(id);
                }

                deselectBrick(id);
                applyGravity();
                saveToHistory();
                updateInfo();
            }
        }

        function deleteSelectedBricks() {
            if (gameState.selectedBrickIds.length === 0) {
                showToast('No bricks selected');
                return;
            }

            const count = gameState.selectedBrickIds.length;
            const idsToDelete = [...gameState.selectedBrickIds];
            idsToDelete.forEach(id => {
                const index = gameState.bricks.findIndex(b => b.id === id);
                if (index > -1) {
                    gameState.bricks.splice(index, 1);
                    const mesh = brickMeshes.get(id);
                    if (mesh) {
                        scene.remove(mesh);
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        brickMeshes.delete(id);
                    }
                }
            });

            gameState.selectedBrickIds = [];
            applyGravity();
            saveToHistory();
            updateInfo();
            showToast(`Deleted ${count} brick(s)`);
        }

        function applyGravity() {
            // Sort by Y position (lowest first)
            gameState.bricks.sort((a, b) => a.position.y - b.position.y);

            let changed = false;

            for (const brick of gameState.bricks) {
                const newY = findSupportLevel(brick);
                if (Math.abs(newY - brick.position.y) > 0.01) {
                    brick.position.y = newY;
                    const mesh = brickMeshes.get(brick.id);
                    if (mesh) {
                        mesh.position.y = newY;
                    }
                    changed = true;
                }
            }

            return changed;
        }

        function findSupportLevel(brick) {
            const local = getLocalBounds(brick.type, brick.rotation);
            const bounds = getWorldBounds(brick.position, brick.type, brick.rotation);
            const tolerance = 0.005;

            const aMinX = bounds.min.x + tolerance;
            const aMaxX = bounds.max.x - tolerance;
            const aMinZ = bounds.min.z + tolerance;
            const aMaxZ = bounds.max.z - tolerance;

            const bottomOffset = local.min.y;
            const currentBottomY = brick.position.y + bottomOffset;

            let maxSupportY = 0;

            for (const other of gameState.bricks) {
                if (other.id === brick.id) continue;

                const bBounds = getWorldBounds(other.position, other.type, other.rotation);

                const overlapX = aMinX < bBounds.max.x && aMaxX > bBounds.min.x;
                const overlapZ = aMinZ < bBounds.max.z && aMaxZ > bBounds.min.z;

                if (overlapX && overlapZ) {
                     if (bBounds.max.y <= currentBottomY + 0.1) {
                        maxSupportY = Math.max(maxSupportY, bBounds.max.y);
                    }
                }
            }

            return maxSupportY - bottomOffset;
        }

        // ==================== ROTATION ====================
        function rotateAxis(axis, delta = 90) {
            gameState.currentRotation[axis] = ((gameState.currentRotation[axis] + delta) % 360 + 360) % 360;
            updateGhostBrick();

            // Also rotate selected bricks
            if (gameState.selectedBrickIds.length > 0) {
                const candidates = [];
                let isBlocked = false;

                // 1. Prepare candidates
                for (const id of gameState.selectedBrickIds) {
                    const brick = gameState.bricks.find(b => b.id === id);
                    if (brick) {
                        const newRot = { ...brick.rotation };
                        newRot[axis] = ((newRot[axis] + delta) % 360 + 360) % 360;
                        candidates.push({ brick, newRot });
                    }
                }

                // 2. Check collisions
                for (const cand of candidates) {
                    // Check against unselected bricks (using the updated checkCollision that supports array of excludes)
                    if (checkCollision(cand.brick.position.x, cand.brick.position.y, cand.brick.position.z, cand.brick.type, cand.newRot, gameState.selectedBrickIds)) {
                        isBlocked = true;
                        break;
                    }

                    // Check against other candidates
                    const aBounds = getWorldBounds(cand.brick.position, cand.brick.type, cand.newRot);
                    const tolerance = 0.005;
                    const aMin = aBounds.min.clone().addScalar(tolerance);
                    const aMax = aBounds.max.clone().subScalar(tolerance);

                    for (const otherCand of candidates) {
                        if (otherCand.brick.id === cand.brick.id) continue;

                        const bBounds = getWorldBounds(otherCand.brick.position, otherCand.brick.type, otherCand.newRot);
                        const bMin = bBounds.min.clone().addScalar(tolerance);
                        const bMax = bBounds.max.clone().subScalar(tolerance);

                        const intersect = (
                            aMin.x < bMax.x && aMax.x > bMin.x &&
                            aMin.y < bMax.y && aMax.y > bMin.y &&
                            aMin.z < bMax.z && aMax.z > bMin.z
                        );

                        if (intersect) {
                            isBlocked = true;
                            break;
                        }
                    }
                    if (isBlocked) break;
                }

                if (isBlocked) {
                    showToast("Rotation blocked by collision");
                    return;
                }

                // 3. Apply rotation
                candidates.forEach(cand => {
                    cand.brick.rotation = cand.newRot;
                    const mesh = brickMeshes.get(cand.brick.id);
                    if (mesh) {
                        mesh.rotation.set(
                            THREE.MathUtils.degToRad(cand.newRot.x),
                            THREE.MathUtils.degToRad(cand.newRot.y),
                            THREE.MathUtils.degToRad(cand.newRot.z)
                        );
                    }
                });
                saveToHistory();
            }
        }

        function resetRotation() {
            gameState.currentRotation = { x: 0, y: 0, z: 0 };
            updateGhostBrick();
            showToast('Rotation reset');
        }

        function updateRotationDisplay() {
            document.getElementById('rot-x').textContent = gameState.currentRotation.x + 'Â°';
            document.getElementById('rot-y').textContent = gameState.currentRotation.y + 'Â°';
            document.getElementById('rot-z').textContent = gameState.currentRotation.z + 'Â°';
        }

        // ==================== HISTORY ====================
        function saveToHistory() {
            // Truncate future history if we're not at the end
            if (gameState.historyIndex < gameState.history.length - 1) {
                gameState.history = gameState.history.slice(0, gameState.historyIndex + 1);
            }

            // Deep clone current state
            const state = JSON.stringify(gameState.bricks.map(b => ({
                id: b.id,
                type: b.type,
                position: { ...b.position },
                rotation: { ...b.rotation },
                color: b.color
            })));

            gameState.history.push(state);

            if (gameState.history.length > CONFIG.maxHistory) {
                gameState.history.shift();
            } else {
                gameState.historyIndex++;
            }
        }

        function undo() {
            if (gameState.historyIndex > 0) {
                gameState.historyIndex--;
                restoreFromHistory();
                showToast('Undo');
            } else {
                showToast('Nothing to undo');
            }
        }

        function redo() {
            if (gameState.historyIndex < gameState.history.length - 1) {
                gameState.historyIndex++;
                restoreFromHistory();
                showToast('Redo');
            } else {
                showToast('Nothing to redo');
            }
        }

        function restoreFromHistory() {
            const state = JSON.parse(gameState.history[gameState.historyIndex]);

            // Clear current meshes
            brickMeshes.forEach((mesh) => {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            });
            brickMeshes.clear();

            // Restore bricks
            gameState.bricks = state;
            gameState.bricks.forEach(brick => createBrickMesh(brick));

            gameState.selectedBrickIds = [];
            updateInfo();
        }

        // ==================== SAVE/LOAD (Removed)

        function clearAll(showConfirm = true) {
            if (showConfirm && gameState.bricks.length > 0) {
                if (!confirm('Clear all bricks? This cannot be undone.')) return;
            }

            brickMeshes.forEach((mesh) => {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            });
            brickMeshes.clear();

            gameState.bricks = [];
            gameState.selectedBrickIds = [];
            gameState.history = [];
            gameState.historyIndex = -1;

            saveToHistory();
            updateInfo();

            if (showConfirm) showToast('All bricks cleared');
        }

        function exportScreenshot() {
            renderer.render(scene, camera);

            try {
                const dataURL = renderer.domElement.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'lego-creation-' + Date.now() + '.png';
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showToast('Screenshot exported!');
            } catch (e) {
                showToast('Export failed');
            }
        }

        // ==================== UI SETUP ====================
        function setupUI() {
            // Brick inventory
            const inventory = document.getElementById('brick-inventory');
            CONFIG.brickTypes.forEach((brick, index) => {
                const btn = document.createElement('button');
                btn.className = 'brick-btn' + (index === 0 ? ' selected' : '');
                btn.textContent = brick.name;
                btn.title = brick.name;
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.brick-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    gameState.currentBrickType = brick;
                    document.getElementById('current-brick').textContent = brick.name;
                    updateGhostBrick();
                });
                inventory.appendChild(btn);
            });

            // Color palette
            const palette = document.getElementById('color-palette');
            CONFIG.colors.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch' + (index === 0 ? ' selected' : '');
                swatch.style.backgroundColor = color.hex;
                swatch.title = color.name;
                swatch.addEventListener('click', () => {
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                    gameState.currentColor = color.hex;
                    updateGhostBrick();
                });
                palette.appendChild(swatch);
            });

            // Tool buttons
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.currentTool = btn.dataset.tool;

                    const toolName = btn.textContent.charAt(0).toUpperCase() + btn.textContent.slice(1);
                    document.getElementById('current-tool-header').textContent = toolName;

                    if (ghostBrick) {
                        ghostBrick.visible = false;
                    }
                });
            });

            // Rotation buttons
            document.getElementById('rotate-x').addEventListener('click', () => rotateAxis('x'));
            document.getElementById('rotate-y').addEventListener('click', () => rotateAxis('y'));
            document.getElementById('rotate-z').addEventListener('click', () => rotateAxis('z'));
            document.getElementById('reset-rotation').addEventListener('click', resetRotation);

            // Action buttons
            document.getElementById('undo-btn').addEventListener('click', undo);
            document.getElementById('redo-btn').addEventListener('click', redo);
            document.getElementById('duplicate-btn').addEventListener('click', duplicateSelected);
            document.getElementById('toggle-grid-btn').addEventListener('click', toggleGrid);
            document.getElementById('export-btn').addEventListener('click', exportScreenshot);
            document.getElementById('clear-btn').addEventListener('click', () => clearAll(true));
            document.getElementById('reset-camera').addEventListener('click', resetCamera);

        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch (e.key) {
                    case 'Delete':
                    case 'Backspace':
                        e.preventDefault();
                        deleteSelectedBricks();
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        rotateAxis('x', 90);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        rotateAxis('x', -90);
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        rotateAxis('y', 90);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        rotateAxis('y', -90);
                        break;
                    case 'q':
                    case 'Q':
                        e.preventDefault();
                        rotateAxis('z', 90);
                        break;
                    case 'e':
                    case 'E':
                        e.preventDefault();
                        rotateAxis('z', -90);
                        break;
                    case 'z':
                    case 'Z':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            if (e.shiftKey) {
                                redo();
                            } else {
                                undo();
                            }
                        }
                        break;
                    case 'y':
                    case 'Y':
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            redo();
                        }
                        break;
                    case 'Escape':
                        deselectAll();
                        break;
                }
            });
        }

        // ==================== UTILITIES ====================
        function generateId() {
            return 'brick_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');

            clearTimeout(toast.hideTimeout);
            toast.hideTimeout = setTimeout(() => {
                toast.classList.remove('show');
            }, 2500);
        }

        function updateInfo() {
            document.getElementById('brick-count').textContent = gameState.bricks.length;
            document.getElementById('brick-count-header').textContent = gameState.bricks.length;
            document.getElementById('selected-count').textContent = gameState.selectedBrickIds.length;
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // ==================== START ====================
        window.addEventListener('load', init);
    </script>
</body>
</html>
